#lang racket

(require rackunit
         "test_helper.rkt")

; a)
; Предположим, что n и d — процедуры одного аргумента (номера элемента i), возвращающие Ni и
; Di элементов цепной дроби. Определите процедуру cont-frac так, чтобы вычисление (cont-frac n d k)
; давало значение k-элементной конечной цепной дроби.
; Проверьте свою процедуру, вычисляя приближения к 1/φ
; Насколько большим пришлось сделать k, чтобы получить приближение, верное с точностью 4 цифры после запятой?

(define (cont-frac n d k)
  (define (rec cur-k)
    (if (= cur-k k)
      (d cur-k)
      (/ (n cur-k) (+ (d cur-k) (rec (+ cur-k 1))))))
  (rec 1))

(define (fi n)
  (exact->inexact (/ 1 (cont-frac (lambda (i) 1)
                                  (lambda (i) 1)
                                  n))))


; Получаем точность до 4 цифры после запятой начиная с k = 12

; тест

(check-close? (fi 100) fi-etalon)

; b)
; Если Ваша процедура cont-frac порождает рекурсивный процесс, напишите вариант, который
; порождает итеративный процесс. Если она порождает итеративный процесс, напишите вариант, 
; порождающий рекурсивный процесс.

(define (cont-frac-iter n d k)
  (define (iter result cur-k)
    (if (= cur-k 0)
      result
      (iter (/ (n cur-k) (+ (d cur-k) result)) (- cur-k 1))))
  (iter 0 k))
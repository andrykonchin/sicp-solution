#lang racket

(require rackunit
         "test_helper.rkt")


; Алгоритмы возведения в степень из этого раздела основаны на повторяющемся умножении. 
; Подобным же образом можно производить умножение с помощью повторяющегося сложения. 
; Следующая процедура умножения (в которой предполагается, что наш язык способен только складывать, 
; но не умножать) аналогична процедуре expt:
;
; (define (* a b)
;   (if (= b 0)
;       0
;       (+ a (* a (- b 1)))))
;
; Этот алгоритм затрачивает количество шагов, линейно пропорциональное b. Предположим теперь,
; что, наряду со сложением, у нас есть операции double, которая удваивает целое число, и halve,
; которая делит (четное) число на 2. Используя их, напишите процедуру, аналогичную fast-expt,
; которая затрачивает логарифмическое число шагов.


(define (fast-* a b)
  (cond 
    ((= b 0) 0)
    ((even? b) (fast-* (double a) (halve b)))
    (else (+ a (fast-* a (- b 1))))))

(define (double x)
  (* x 2))

(define (halve even-x)
  (if (even? even-x)
      (/ even-x 2)
      null))

; тесты

(check-eq? (fast-* 3 0) 0 )
(check-eq? (fast-* 2 5) 10)
(check-eq? (fast-* 3 6) 18)
(check-eq? (fast-* 4 5) 20)
(check-eq? (fast-* 3 5) 15)

#lang racket

(require rackunit
         "test_helper.rkt")

; напишите процедуру search-for-primes, которая проверяет на простоту 
; все нечетные числа в заданном диапазоне. С помощью этой процедуры найдите наименьшие
; три простых числа после 1000; после 10 000; после 100 000; после 1 000 000. Посмотрите, сколько
; времени затрачивается на каждое простое число. Поскольку алгоритм проверки имеет порядок
; роста Θ(√n), Вам следовало бы ожидать, что проверка на простоту чисел, близких к 10 000,
; занимает в √10 раз больше времени, чем для чисел, близких к 1000. Подтверждают ли это Ваши
; замеры времени? Хорошо ли поддерживают предсказание √n данные для 100 000 и 1 000 000?
; Совместим ли Ваш результат с предположением, что программы на Вашей машине затрачивают
; на выполнение задач время, пропорциональное числу шагов?


(define (search-for-primes a b)
  (if (> a b)
      '()
      (if (and (not (even? a)) (timed-prime-test a))
          (append (list a) (search-for-primes (+ a 2) b))
          (search-for-primes (+ a 1) b))))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (current-inexact-milliseconds)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (or (report-prime (- (current-inexact-milliseconds) start-time)) #t)
      #f))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
  
(define (divides? a b)
  (= (remainder b a) 0))

(define (square x) (* x x))


; наименьшие три простых числа после 1 000
;(search-for-primes 1000 1020) ; => (1009 1013 1019)


; наименьшие три простых числа после 10 000
;(search-for-primes 10000 10038) ; => (10007 10009 10037)

; наименьшие три простых числа после 100 000
;(search-for-primes 100000 100045) ; => (100003 100019 100043)

; наименьшие три простых числа после 1000 000
;(search-for-primes 1000000 1000038) ; => (1000003 1000033 1000037)


; Так как на предложенных диаппазонах время проверки занимает меньше 1 мс, проведем вычисления на больших числах

; Порядок         Примерное время проверки в мс Простые числа
; 100000000       2.0                           (100000007 100000037 100000039)
; 1000000000      5.0                           (1000000007 1000000009 1000000021)
; 10000000000     22.0                          (10000000019 10000000033 10000000061)
; 100000000000    61.0                          (100000000003 100000000019 100000000057)
; 1000000000000   208.0                         (1000000000039 1000000000061 1000000000063)

; Замеры времени подтверждают, что при увеличении шагов в 10 раз, затрачивается время на проверку в ~ √10 раз больше. 
; Этот результат совместим с предложением, что время выполнения программ пропорционально числу шагов


; тесты

(check-equal? (search-for-primes 1 20) '(1 3 5 7 11 13 17 19))